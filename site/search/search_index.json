{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unidad 5. POO Clases y Objetos","text":"<ul> <li>Unidad 5 - POO Clases y Objetos<ul> <li>1. Clases y Objetos<ul> <li>1.1 Repaso del concepto de objeto</li> <li>1.2 El concepto de clase</li> </ul> </li> <li>2. Estructura y miembros de una clase<ul> <li>2.1 Declaraci\u00f3n de una clase<ul> <li>Para saber m\u00e1s</li> <li>Ejercicio</li> </ul> </li> <li>2.1 Cabecera de una clase</li> <li>2.3 Miembros est\u00e1ticos o de clase<ul> <li>Ejercicio</li> </ul> </li> <li>2.4 Cuerpo de una clase<ul> <li>Ejercicio</li> </ul> </li> </ul> </li> <li>3. Utilizaci\u00f3n de los m\u00e9todos y atributos de una clase<ul> <li>Para saber m\u00e1s</li> <li>3.1 Declaraci\u00f3n de un objeto<ul> <li>Ejercicio</li> </ul> </li> <li>3.2 Creaci\u00f3n de un objeto<ul> <li>Ejercicio</li> </ul> </li> <li>3.3 Manipulaci\u00f3n de un objeto<ul> <li>Ejercicio</li> </ul> </li> </ul> </li> <li>4. Encapsulaci\u00f3n, control de acceso y visibilidad<ul> <li>Para saber m\u00e1s</li> <li>4.1 Ocultaci\u00f3n de atributos. M\u00e9todos de acceso</li> <li>4.2 Ocultaci\u00f3n de m\u00e9todos<ul> <li>Ejercicio</li> </ul> </li> </ul> </li> <li>5. Constructores<ul> <li>5.1 Concepto de constructor<ul> <li>5.1.1 Sobrecarga de m\u00e9todos</li> </ul> </li> <li>5.2 Creaci\u00f3n de constructores<ul> <li>Reflexiona</li> <li>5.2.1 La referencia this</li> <li>Para saber m\u00e1s</li> <li>Ejercicio</li> </ul> </li> <li>5.3 Utilizaci\u00f3n de constructores</li> <li><ul> <li>Para saber m\u00e1s</li> <li>Ejercicio</li> </ul> </li> <li>5.4 Constructores copia<ul> <li>Ejercicio</li> </ul> </li> <li>5.5 Destrucci\u00f3n de objetos</li> </ul> </li> <li>Anexo I.- Formateado de cadenas en Java<ul> <li>Listado de conversiones m\u00e1s utilizada y ejemplos.</li> <li>Para saber m\u00e1s</li> </ul> </li> </ul> </li> </ul> Fecha Versi\u00f3n Descripci\u00f3n 07/12/2021 1.0.0 Versi\u00f3n inicial 10/09/2025 1.0.1 Revisi\u00f3n del tema."},{"location":"#unidad-5-poo-clases-y-objetos","title":"Unidad 5 - POO Clases y Objetos","text":""},{"location":"#1-clases-y-objetos","title":"1. Clases y Objetos","text":"<p>Las clases representan un tipo de dato complejo y est\u00e1n compuestas por atributos y m\u00e9todos. A diferencia de los arrays, las clases agrupan datos de diferentes  tipos que se denominan atributos y tambi\u00e9n m\u00e9todos que nos permiten  trabajar con esos atributos.</p> <p>Una clase por tanto, especifica las caracter\u00edsticas comunes de un conjunto de objetos. Sin embargo, cuando queramos utilizar ese tipo de dato en nuestros  programas tendremos que crear un objeto. De esta forma los programas que escribas estar\u00e1n formados por un conjunto de clases a partir de las cuales ir\u00e1s creando objetos que se interrelacionar\u00e1n unos con otros. En muchos casos tambi\u00e9n se  habla de las clases como de las plantillas o planos a partir de los  cuales se crean los objetos.</p> <p>Adem\u00e1s de ellos, veremos que las clases nos van a permitir organizar  nuestros programas de otra manera. Es a lo que vamos a llamar  programaci\u00f3n orientada a objetos (POO). Vamos a utilizar los mismos  elementos que hemos utilizado hasta ahora pero organizados en base a  clases.</p>"},{"location":"#11-repaso-del-concepto-de-objeto","title":"1.1 Repaso del concepto de objeto","text":"<p>Desde el comienzo del m\u00f3dulo llevas utilizando el concepto de objeto para desarrollar tus programas de ejemplo.  En las unidades anteriores se ha descrito un objeto como una entidad que contiene informaci\u00f3n y que es capaz de realizar ciertas operaciones con esa informaci\u00f3n. Seg\u00fan los valores que tenga esa informaci\u00f3n el objeto tendr\u00e1 un estado determinado y seg\u00fan las operaciones que pueda llevar a cabo con esos datos ser\u00e1 responsable de un comportamiento concreto.</p> <p>Recuerda que entre las caracter\u00edsticas fundamentales de un objeto se encontraban la identidad (los objetos son \u00fanicos y por tanto distinguibles entre s\u00ed, aunque pueda haber objetos exactamente iguales), un estado (los atributos que describen al objeto y los valores que tienen en cada momento) y un determinado comportamiento (acciones que se pueden realizar sobre el objeto).</p> <p>Algunos ejemplos de objetos que podr\u00edamos imaginar podr\u00edan ser:</p> <ul> <li>Un coche de color rojo, marca SEAT, modelo Toledo, del a\u00f1o 2003. En este ejemplo tenemos una serie de atributos, como el color (en este caso rojo), la marca, el modelo, el a\u00f1o, etc. As\u00ed mismo tambi\u00e9n podr\u00edamos imaginar determinadas caracter\u00edsticas como la cantidad de combustible que le queda, o el n\u00famero de kil\u00f3metros recorridos hasta el momento.</li> <li>Un coche de color amarillo, marca Opel, modelo Astra, del a\u00f1o 2002.</li> <li>Otro coche de color amarillo, marca Opel, modelo Astra y tambi\u00e9n del a\u00f1o 2002. Se tratar\u00eda de otro objeto con las mismas propiedades que el anterior, pero ser\u00eda un segundo objeto.</li> <li>Un cocodrilo de cuatro metros de longitud y de veinte a\u00f1os de edad.</li> <li>Un c\u00edrculo de radio 2 cent\u00edmetros, con centro en las coordenadas (0,0) y relleno de color amarillo.</li> <li>Un c\u00edrculo de radio 3 cent\u00edmetros, con centro en las coordenadas (1,2) y relleno de color verde.</li> </ul> <p>Si observas los ejemplos anteriores podr\u00e1s distinguir sin demasiada dificultad al menos tres familias de objetos diferentes, que no tienen nada que ver una con otra:</p> <ul> <li>Los coches.</li> <li>Los c\u00edrculos.</li> <li>Los cocodrilos.</li> </ul> <p>Es de suponer entonces que cada objeto tendr\u00e1 determinadas posibilidades de comportamiento (acciones) dependiendo de la familia a la que pertenezcan. Por ejemplo, en el caso de los coches podr\u00edamos imaginar acciones como: arrancar, frenar, acelerar, cambiar de marcha, etc. En el caso de los cocodrilos podr\u00edas imaginar otras acciones como: desplazarse, comer, dormir, cazar, etc. Para el caso del c\u00edrculo se podr\u00edan plantear acciones como: c\u00e1lculo de la superficie del c\u00edrculo, c\u00e1lculo de la longitud de la circunferencia que lo rodea, etc.</p> <p>Por otro lado, tambi\u00e9n podr\u00edas imaginar algunos atributos cuyos valores podr\u00edan ir cambiando en funci\u00f3n de las acciones que se realizaran sobre el objeto: ubicaci\u00f3n del coche (coordenadas), velocidad instant\u00e1nea, kil\u00f3metros recorridos, velocidad media, cantidad de combustible en el dep\u00f3sito, etc. En el caso de los cocodrilos podr\u00edas imaginar otros atributos como: peso actual, el n\u00famero de dientes actuales (ir\u00e1 perdiendo algunos a lo largo de su vida), el n\u00famero de presas que ha cazado hasta el momento, etc.</p> <p>Como puedes ver, un objeto puede ser cualquier cosa que puedas describir en t\u00e9rminos de atributos y acciones.</p> Un objeto no es m\u00e1s que la representaci\u00f3n de cualquier entidad concreta o abstracta que puedas percibir o imaginar y que pueda resultar de utilidad para modelar los elementos el entorno del problema que deseas resolver."},{"location":"#12-el-concepto-de-clase","title":"1.2 El concepto de clase","text":"<p>Est\u00e1 claro que dentro de un mismo programa tendr\u00e1s la oportunidad de encontrar decenas, cientos o incluso miles de objetos. En algunos casos no se parecer\u00e1n en nada unos a otros, pero tambi\u00e9n podr\u00e1s observar que habr\u00e1 muchos que tengan un gran parecido, compartiendo un mismo comportamiento y unos mismos atributos. Habr\u00e1 muchos objetos que s\u00f3lo se diferenciaran por los valores que toman algunos de esos atributos.</p> <p>Es aqu\u00ed donde entra en escena el concepto de clase. Est\u00e1 claro que no podemos definir la estructura y el comportamiento de cada objeto cada vez que va a ser utilizado dentro de un programa, pues la escritura del c\u00f3digo ser\u00eda una tarea interminable y redundante. La idea es poder disponer de una plantilla o modelo para cada conjunto de objetos que sean del mismo tipo, es decir, que tengan los mismos atributos y un comportamiento similar.</p> Una clase consiste en la definici\u00f3n de un tipo de objeto. Se trata de una descripci\u00f3n detallada de c\u00f3mo van a ser los objetos que pertenezcan a esa clase indicando qu\u00e9 tipo de informaci\u00f3n contendr\u00e1n (atributos) y c\u00f3mo se podr\u00e1 interactuar con ellos (comportamiento). <p>Como ya has visto en unidades anteriores,  una clase consiste en un plantilla en la que se especifican:</p> <ul> <li>Los atributos que van a ser comunes a todos los objetos que pertenezcan a esa clase (informaci\u00f3n).</li> <li>Los m\u00e9todos que permiten interactuar con esos objetos (comportamiento). </li> </ul> <p>A partir de este momento podr\u00e1s hablar ya sin confusi\u00f3n de objetos y de clases, sabiendo que los primeros son instancias concretas de las segundas, que no son m\u00e1s que una abstracci\u00f3n o definici\u00f3n.</p> <p>Si nos volvemos a fijar en los ejemplos de objetos del apartado anterior podr\u00edamos observar que las clases ser\u00edan lo que clasificamos como \"familias\" de objetos (coches, cocodrilos y c\u00edrculos).</p> En el lenguaje cotidiano de muchos programadores puede ser habitual la confusi\u00f3n entre los t\u00e9rminos clase y objeto. Aunque normalmente el contexto nos permite distinguir si nos estamos refiriendo realmente a una clase (definici\u00f3n abstracta) o a un objeto (instancia concreta), hay que tener cuidado con su uso para no dar lugar a interpretaciones err\u00f3neas, especialmente durante el proceso de aprendizaje."},{"location":"#2-estructura-y-miembros-de-una-clase","title":"2. Estructura y miembros de una clase","text":"<p>Para declarar una clase en Java se usa la palabra reservada <code>class</code>. En la declaraci\u00f3n de una clase vas a encontrar:</p> <ul> <li>Cabecera de la clase. Compuesta por una serie de modificadores de acceso, la palabra reservada <code>class</code> y el nombre de la clase.</li> <li>Cuerpo de la clase. En \u00e9l se especifican los distintos miembros de la clase: atributos y m\u00e9todos. Es decir, el contenido de la clase.</li> </ul> <p></p> <p>Como puedes observar, el cuerpo de la clase es donde se declaran los atributos que caracterizar\u00e1n a los objetos que se crean a partir de la clase y  donde se define e implementa el comportamiento de dichos objetos; es  decir, donde se declaran e implementan los m\u00e9todos para manipular esos objetos.</p>"},{"location":"#21-declaracion-de-una-clase","title":"2.1 Declaraci\u00f3n de una clase","text":"<p>La declaraci\u00f3n de una clase en Java tiene la siguiente estructura general:</p> <pre><code>[modificadores] class  &lt;NombreClase&gt; [herencia] [interfaces] { // Cabecera de la clase\n\n     // Cuerpo de la clase\n\n     Declaraci\u00f3n de los atributos\n\n     Declaraci\u00f3n de los m\u00e9todos\n\n}\n</code></pre> <p>Un ejemplo b\u00e1sico pero completo podr\u00eda ser:</p> <pre><code>class Punto {\n   // Declaraci\u00f3n de los atributos: Estado\n   int x, y;\n\n   // Declaraci\u00f3n de los m\u00e9todos: Comportamiento\n   int obtenerX () {\n      return x;\n   } \n\n   int obtenerY() {\n      return y;\n   }\n\n   void establecerX(int valor) {\n      x = valor;\n   }\n\n   void establecerY(int valor) {\n      y = valor;\n   }\n}\n</code></pre> <p>En este caso se trata de una clase muy sencilla en la que el cuerpo  de la clase, el \u00e1rea entre las llaves, contiene el c\u00f3digo y las  declaraciones necesarias para que los objetos que se construyan  bas\u00e1ndose en esta clase puedan funcionar apropiadamente en un programa.  En concreto, contendr\u00e1 las declaraciones de atributos para contener el  estado del objeto y los m\u00e9todos que permitan manipular los objetos  creados a partir de esa clase.</p> <p>Si te fijas en los distintos programas que hemos desarrollado hasta  ahora, podr\u00e1s observar que cada uno de esos programas era en s\u00ed mismo  una clase Java: se declaraban con la palabra reservada <code>class</code> y conten\u00edan algunos atributos (variables) as\u00ed como algunos m\u00e9todos (como m\u00ednimo el m\u00e9todo <code>main</code>).</p> <p>En el ejemplo anterior hemos visto lo m\u00ednimo que se tiene que indicar en la cabecera de una clase (el nombre de la clase y la palabra reservada <code>class</code>). Se puede proporcionar bastante m\u00e1s informaci\u00f3n mediante modificadores y otros indicadores como por ejemplo el nombre de su superclase (si es que esa clase hereda de otra), si implementa alg\u00fan interfaz y algunas cosas m\u00e1s que iremos aprendiendo poco a poco.</p> <p>A la hora de implementar una clase Java debes tener en cuenta:</p> <ul> <li>Por convenio, se ha decidido que en lenguaje Java los nombres de las clases deben de empezar por una letra may\u00fascula. As\u00ed, cada vez que observes en el c\u00f3digo una palabra con la primera  letra en may\u00fascula sabr\u00e1s que se trata de una clase sin necesidad de  tener que buscar su declaraci\u00f3n. Adem\u00e1s, si el nombre de la clase est\u00e1 formado por varias palabras, cada una de ellas tambi\u00e9n tendr\u00e1 su primera letra en may\u00fascula. Siguiendo esta recomendaci\u00f3n, algunos ejemplos de nombres de clases  podr\u00edan ser: Recta, Circulo, Coche, CocheDeportivo, Jugador,  JugadorFutbol, AnimalMarino, AnimalAcuatico, etc.</li> <li>Tanto la definici\u00f3n como la implementaci\u00f3n de una clase se incluye en el mismo archivo (archivo \".java\"). En otros lenguajes como por ejemplo C++, definici\u00f3n e implementaci\u00f3n podr\u00edan ir en archivos separados (por  ejemplo en C++, ser\u00edan sendos archivos con extensiones \".h\" y \".cpp\").</li> <li>El archivo debe tener el mismo nombre que la clase si queremos poder  utilizarla desde otras clases que se encuentren fuera de ese archivo.</li> </ul>"},{"location":"#para-saber-mas","title":"Para saber m\u00e1s","text":"<p>Si quieres ampliar un poco m\u00e1s sobre este tema puedes echar un vistazo a los tutoriales de iniciaci\u00f3n de Java en el sitio web de Oracle (en  ingl\u00e9s): Java Classes.</p>"},{"location":"#ejercicio","title":"Ejercicio","text":"<p>Imagina que quieres escribir una clase que represente un rect\u00e1ngulo en el plano. Para ello has pensado en los siguientes atributos:</p> <ul> <li>Atributos x1, y1, que representan la coordenadas del v\u00e9rtice inferior izquierdo del rect\u00e1ngulo. Ambos de tipo <code>double</code> (n\u00fameros reales).</li> <li>Atributos x2, y2, que representan las coordenadas del v\u00e9rtice superior derecho del rect\u00e1ngulo. Tambi\u00e9n de tipo <code>double</code> (n\u00fameros reales).</li> </ul> <p>Con estos dos puntos (x1, y1) y (x2, y2) se puede definir perfectamente la ubicaci\u00f3n de un rect\u00e1ngulo en el plano.</p> <p>Escribe una clase que contenga todos esos atributos teniendo en cuenta que queremos que sea una clase visible desde cualquier parte del programa y que sus atributos sean tambi\u00e9n accesibles desde cualquier parte del c\u00f3digo.</p>"},{"location":"#21-cabecera-de-una-clase","title":"2.1 Cabecera de una clase","text":"<p>En general, la declaraci\u00f3n de una clase puede incluir los siguientes elementos y en el siguiente orden:</p> <ul> <li>Modificadores tales como public, abstract<code>o</code>final`.</li> <li>El nombre de la clase (con la primera letra de cada palabra en may\u00fasculas, por convenio).</li> <li>El nombre de su clase padre (superclase), si es que se especifica, precedido por la palabra reservada extends (\"extiende\" o \"hereda de\").</li> <li>Una lista separada por comas de interfaces que son implementadas por la clase, precedida por la palabra reservada implements (\"implementa\").</li> </ul> <p>A continuaci\u00f3n, vendr\u00e1 el cuerpo de la clase, encerrado entre llaves {}.</p> <p>La sintaxis completa de una cabecera queda de la siguiente forma:</p> <pre><code>[modificadores]\n\nclass &lt;NombreClase&gt; [extends &lt;NombreSuperClase&gt;][implements\n\n&lt;NombreInterface1&gt;] [[implements &lt;NombreInterface2&gt;] ...] {\n</code></pre> <p>En el ejemplo anterior de la clase <code>Punto</code> ten\u00edamos la siguiente cabecera:</p> <pre><code>class Punto {\n</code></pre> <p>En este caso no hay modificadores, ni indicadores de *herencia*, ni implementaci\u00f3n de interfaces. Tan solo la palabra reservada <code>class</code> y el nombre de la clase. Es lo m\u00ednimo que puede haber en la cabecera de una clase.</p> <p>La herencia y las interfaces las veremos m\u00e1s adelante. Vamos a ver ahora cu\u00e1les son los modificadores que se pueden indicar al crear la clase y qu\u00e9 efectos tienen. Los modificadores de clase son:</p> <pre><code>[public] [final | abstract]\n</code></pre> <p>Veamos qu\u00e9 significado tiene cada uno de ellos:</p> <ul> <li>Modificador <code>public</code>. Indica que la clase es visible y se pueden crear objetos de esa clase desde cualquier otra clase. Es decir, desde cualquier otra parte del programa. Si no se especifica este  modificador, la clase s\u00f3lo podr\u00e1 ser utilizada desde clases que est\u00e9n en el mismo paquete. El concepto de paquete lo veremos m\u00e1s adelante. S\u00f3lo puede haber una clase <code>public</code> (clase principal) en un archivo .java. El resto de clases que se definan en ese archivo no ser\u00e1n p\u00fablicas.</li> <li>Modificador <code>abstract</code>. Indica que la clase es abstracta. Una clase abstracta no es instanciable. Es decir, no es posible crear objetos de esa clase y habr\u00e1 que utilizar clases que hereden de ella. En este momento es  posible que te parezca que no tenga sentido que esto pueda suceder (si  no puedes crear objetos de esa clase, \u00bfpara qu\u00e9 la quieres?), pero puede resultar \u00fatil a la hora de crear una jerarqu\u00eda de clases. Esto lo ver\u00e1s tambi\u00e9n m\u00e1s adelante al estudiar el concepto de herencia.</li> <li>Modificador <code>final</code>. Indica que no podr\u00e1s crear clases que hereden de ella. Tambi\u00e9n volver\u00e1s a este modificador cuando estudies el concepto de herencia. Los modificadores <code>final</code> y <code>abstract</code> son excluyentes, s\u00f3lo se puede utilizar uno de ellos.</li> </ul> <p>Todos estos modificadores y palabras reservadas las iremos viendo  poco a poco, as\u00ed que no te preocupes demasiado por intentar entender  todas ellas en este momento.</p> <p>En el ejemplo anterior de la clase <code>Punto</code> tendr\u00edamos una  clase que ser\u00eda s\u00f3lo visible (utilizable) desde el mismo paquete en el  que se encuentra la clase (modificador de acceso por omisi\u00f3n o de  paquete, o <code>package</code>). Desde fuera de ese paquete no ser\u00eda  visible o accesible. Para poder utilizarla desde cualquier parte del  c\u00f3digo del programa bastar\u00eda con a\u00f1adir el atributo public: public class Punto.</p>"},{"location":"#23-miembros-estaticos-o-de-clase","title":"2.3 Miembros est\u00e1ticos o de clase","text":"<p>Cada vez que se produce una instancia de una clase (es decir, se crea un objeto de esa clase), se desencadenan una serie de procesos  (construcci\u00f3n del objeto) que dan lugar a la creaci\u00f3n en memoria de un  espacio f\u00edsico que constituir\u00e1 el objeto creado. De esta manera cada  objeto tendr\u00e1 sus propios miembros a imagen y semejanza de la plantilla  propuesta por la clase.</p> <p>Por otro lado, podr\u00e1s encontrarte con ocasiones en las que  determinados miembros de la clase (atributos o m\u00e9todos) no tienen  demasiado sentido como partes del objeto, sino m\u00e1s bien como partes de  la clase en s\u00ed (partes de la plantilla, pero no de cada instancia de esa plantilla). Por ejemplo, si creamos una clase Coche y quisi\u00e9ramos  disponer de un atributo con el nombre de la clase (un atributo de tipo <code>String</code> con la cadena \"Coche\"), no tiene mucho sentido replicar ese atributo  para todos los objetos de la clase Coche, pues para todos va a tener  siempre el mismo valor (la cadena \"Coche\"). Es m\u00e1s, ese atributo puede  tener sentido y existencia al margen de la existencia de cualquier  objeto de tipo Coche. Podr\u00eda no haberse creado ning\u00fan objeto de la clase Coche y sin embargo seguir\u00eda teniendo sentido poder acceder a ese  atributo de nombre de la clase, pues se trata en efecto de un atributo  de la propia clase m\u00e1s que de un atributo de cada objeto instancia de la clase.</p> <p>Si te fijas en las clases que hemos utilizado hasta ahora, tanto Math como Array nos permit\u00edan utilizar m\u00e9todos sin crear ning\u00fan objeto  antes. Todos esos m\u00e9todos que hemos usado eran m\u00e9todos est\u00e1ticos.</p> <p>Para poder definir miembros est\u00e1ticos en Java se utiliza el modificador static. Los miembros, tanto atributos como m\u00e9todos, declarados utilizando este  modificador son conocidos como miembros est\u00e1ticos o miembros de clase. A continuaci\u00f3n vas a estudiar la creaci\u00f3n y utilizaci\u00f3n de atributos y  m\u00e9todos. En cada caso ver\u00e1s c\u00f3mo declarar y usar atributos est\u00e1ticos y m\u00e9todos est\u00e1ticos.</p>"},{"location":"#ejercicio_1","title":"Ejercicio","text":"<p>Ampliar el ejercicio anterior del rect\u00e1ngulo incluyendo los siguientes atributos:</p> <ul> <li>Atributo numRectangulos, que almacena el n\u00famero de objetos de tipo rect\u00e1ngulo creados hasta el momento.</li> <li>Atributo nombre, que almacena el nombre que se le quiera dar a cada rect\u00e1ngulo.</li> <li>Atributo nombreFigura, que almacena el nombre de la clase, es decir, \"Rect\u00e1ngulo\".</li> <li>Atributo PI, que contiene el nombre de la constante PI con una precisi\u00f3n de cuatro cifras decimales.</li> </ul> <p>No se desea que los atributos nombre y numRectangulos puedan ser visibles desde fuera de la clase. Y adem\u00e1s se desea que la clase sea accesible solamente desde su propio paquete.</p>"},{"location":"#24-cuerpo-de-una-clase","title":"2.4 Cuerpo de una clase","text":"<p>Como ya has visto anteriormente, el cuerpo de una clase se encuentra  encerrado entre llaves y contiene la declaraci\u00f3n e implementaci\u00f3n de sus miembros. Los miembros de una clase pueden ser:</p> <ul> <li>Atributos, que especifican los datos que podr\u00e1 contener un objeto de la clase.</li> <li>M\u00e9todos, que implementan las acciones que se podr\u00e1n realizar con un objeto de la clase.</li> </ul> <p>Una clase puede no contener en su declaraci\u00f3n atributos o m\u00e9todos,  pero debe de contener al menos uno de los dos (la clase no puede ser  vac\u00eda).</p> <p>En el ejemplo anterior donde se defin\u00eda una clase <code>Punto</code>, tendr\u00edamos los siguientes atributos:</p> <ul> <li>Atributo <code>x</code>, de tipo <code>int</code>.</li> <li>Atributo <code>y</code>, de tipo <code>int</code>.</li> </ul> <p>Es decir, dos valores de tipo entero. Cualquier objeto de la clase <code>Punto</code> que sea creado almacenar\u00e1 en su interior dos n\u00fameros enteros (<code>x</code> e <code>y</code>). Cada objeto diferente de la clase <code>Punto</code> contendr\u00e1 sendos valores x e y, que podr\u00e1n coincidir o no con el contenido de otros objetos de esa misma clase <code>Punto</code>.</p> <p>Por ejemplo, si se han declarado varios objetos de tipo <code>Punto</code>:</p> <pre><code>Punto p1, p2, p3;\n</code></pre> <p>Sabremos que cada uno de esos objetos <code>p1</code>, <code>p2</code>y <code>p3</code> contendr\u00e1n un par de coordenadas <code>(x, y)</code> que definen el estado de ese objeto. Puede que esos valores coincidan con los de otros objetos de tipo <code>Punto</code>, o puede que no, pero en cualquier caso ser\u00e1n objetos diferentes creados a partir del mismo molde (de la misma clase).</p> <p></p> <p>Por otro lado, la clase <code>Punto</code> tambi\u00e9n defin\u00eda una serie de m\u00e9todos:</p> <pre><code>int obtenerX () {\n   return x;\n}\nint obtenerY() {\n   return y;\n}\nvoid establecerX(int valor) {\n   x = valor;\n}\nvoid establecerY(int valor) {\n   y = valor;\n}\n</code></pre> <p>Cada uno de esos m\u00e9todos puede ser llamado desde cualquier objeto que sea una instancia de la clase <code>Punto</code>. Se trata de operaciones que permiten manipular los datos (atributos)  contenidos en el objeto bien para calcular otros datos o bien para  modificar los propios atributos.</p>"},{"location":"#ejercicio_2","title":"Ejercicio","text":"<p>Vamos a seguir ampliando la clase en la que se representa un rect\u00e1ngulo en el plano (clase Rectangulo). Para ello has pensado en los siguientes m\u00e9todos p\u00fablicos:</p> <ul> <li>M\u00e9todos obtenerNombre y establecerNombre, que permiten el acceso y modificaci\u00f3n del atributo nombre del rect\u00e1ngulo.</li> <li>M\u00e9todo calcularSuperfice, que calcula el \u00e1rea encerrada por el rect\u00e1ngulo.</li> <li>M\u00e9todo calcularPer\u00edmetro, que calcula la longitud del per\u00edmetro del rect\u00e1ngulo.</li> <li>M\u00e9todo desplazar, que mueve la ubicaci\u00f3n del rect\u00e1ngulo en el plano en una cantidad X (para el eje X) y otra cantidad Y (para el eje Y). Se trata simplemente de sumar el desplazamiento X a las coordenadas x1 y x2, y el desplazamiento Y a las coordenadas y1 e y2. Los par\u00e1metros de entrada de este m\u00e9todo ser\u00e1n por tanto X e Y, de tipo <code>double</code>.</li> <li>M\u00e9todo obtenerNumRectangulos, que devuelve el n\u00famero de rect\u00e1ngulos creados hasta el momento.</li> </ul> <p>Incluye la implementaci\u00f3n de cada uno de esos m\u00e9todos en la clase Rectangulo.</p>"},{"location":"#3-utilizacion-de-los-metodos-y-atributos-de-una-clase","title":"3. Utilizaci\u00f3n de los m\u00e9todos y atributos de una clase","text":"<p>Una vez que ya tienes implementada una clase con todos sus atributos y m\u00e9todos, ha llegado el momento de utilizarla, es decir, de instanciar objetos de esa clase e interaccionar con ellos. En unidades anteriores ya has visto c\u00f3mo declarar un objeto de una clase determinada, instanciarlo con el operador <code>new</code> y utilizar sus m\u00e9todos y atributos.</p>"},{"location":"#para-saber-mas_1","title":"Para saber m\u00e1s","text":"<p>Puedes echar un vistazo a los art\u00edculos sobre la creaci\u00f3n y uso de objetos en Java en los manuales de Oracle (en ingl\u00e9s):</p> <ul> <li>Creating Objects.</li> <li>Using Objects.</li> </ul>"},{"location":"#31-declaracion-de-un-objeto","title":"3.1 Declaraci\u00f3n de un objeto","text":"<p>Como ya has visto en unidades anteriores, la declaraci\u00f3n de un objeto se realiza exactamente igual que la declaraci\u00f3n de una variable de cualquier tipo:</p> <pre><code>&lt;tipo&gt; nombreVariable;\n</code></pre> <p>En este caso el tipo ser\u00e1 alguna clase que ya hayas implementado o bien alguna de las proporcionadas por la biblioteca de Java o por alguna otra biblioteca escrita por terceros.</p> <p>Por ejemplo: </p> <pre><code>Punto p1;\n\nRectangulo r1, r2;\n\nCoche cocheAntonio;\n\nString palabra; \n</code></pre> <p>Esas variables (p1, r1, r2, cocheAntonio, palabra) en realidad son referencias (tambi\u00e9n conocidas como punteros o direcciones de memoria) que apuntan (hacen \"referencia\") a un objeto (una zona de memoria) de la clase indicada en la declaraci\u00f3n. </p> <p>Como ya estudiaste en la unidad dedicada a los objetos, un objeto reci\u00e9n declarado (referencia reci\u00e9n creada) no apunta a nada. Se dice que la referencia est\u00e1 vac\u00eda o que es una referencia nula (la variable objeto contiene el valor <code>null</code>). Es decir, la variable existe y est\u00e1 preparada para guardar una direcci\u00f3n de memoria que ser\u00e1 la zona donde se encuentre el objeto al que har\u00e1 referencia, pero el objeto a\u00fan no existe (no ha sido creado o instanciado). Por tanto se dice que apunta a un objeto nulo o inexistente.</p> <p>Para que esa variable (referencia) apunte realmente a un objeto (contenga una referencia o direcci\u00f3n de memoria que apunte a una zona de memoria en la que se ha reservado espacio para un objeto) es necesario crear o instanciar el objeto. Para ello se utiliza el operador <code>new</code>.</p>"},{"location":"#ejercicio_3","title":"Ejercicio","text":"<p>Utilizando la clase  Rectangulo  implementada en ejercicios anteriores, indica como declarar\u00edas tres objetos (variables) de esa clase llamados  r1, r2, r3 .</p>"},{"location":"#32-creacion-de-un-objeto","title":"3.2 Creaci\u00f3n de un objeto","text":"<p>Para poder crear un objeto (instancia de una clase) es necesario utilizar el operador <code>new</code>, el cual tiene la siguiente sintaxis:</p> <pre><code>nombreObjeto = new &lt;ConstructorClase&gt; ([listaParametros]);\n</code></pre> <p>El constructor de una clase (ConstructorClase) es un m\u00e9todo especial que tiene toda clase y cuyo nombre coincide con el de  la clase. Es quien se encarga de crear o construir el objeto,  solicitando la reserva de memoria necesaria para los atributos e  inicializ\u00e1ndolos a alg\u00fan valor si fuera necesario. Dado que el  constructor es un m\u00e9todo m\u00e1s de la clase, podr\u00e1 tener tambi\u00e9n su lista  de par\u00e1metros como tienen todos los m\u00e9todos.</p> <p>De la tarea de reservar memoria para la estructura del objeto (sus  atributos m\u00e1s alguna otra informaci\u00f3n de car\u00e1cter interno para el  entorno de ejecuci\u00f3n) se encarga el propio entorno de ejecuci\u00f3n de Java. Es decir, que por el hecho de ejecutar un m\u00e9todo constructor, el  entorno sabr\u00e1 que tiene que realizar una serie de tareas (solicitud de  una zona de memoria disponible, reserva de memoria para los atributos,  enlace de la variable objeto a esa zona, etc.) y se pondr\u00e1 r\u00e1pidamente a desempe\u00f1arlas.</p> <p>Cuando escribas el c\u00f3digo de una clase no es necesario que  implementes el m\u00e9todo constructor si no quieres hacerlo. Java se encarga de dotar de un constructor por omisi\u00f3n (tambi\u00e9n conocido como constructor por defecto) a toda clase. Ese constructor por omisi\u00f3n se ocupar\u00e1 exclusivamente de  las tareas de reserva de memoria. Si deseas que el constructor realice  otras tareas adicionales, tendr\u00e1s que escribirlo t\u00fa. El constructor por  omisi\u00f3n no tiene par\u00e1metros.</p> El constructor por defecto no se ve en el c\u00f3digo de una clase. Lo  incluir\u00e1 el compilador de Java al compilar la clase si descubre que no  se ha creado ning\u00fan m\u00e9todo constructor para esa clase. <p>Algunos ejemplos de instanciaci\u00f3n o creaci\u00f3n de objetos podr\u00edan ser:</p> <pre><code>p1 = new Punto();\n\nr1 = new Rectangulo();\n\nr2 = new Rectangulo;\n\ncocheAntonio = new Coche();\n\npalabra = new String; \n</code></pre>"},{"location":"#ejercicio_4","title":"Ejercicio","text":"<p>Ampliar el ejercicio anterior instanciando los objetos r1, r2, r3 mediante el constructor por defecto.</p> <p>Ampliar el ejercicio anterior instanciando los objetos r1, r2, r3 mediante el constructor por defecto.</p> <pre><code>Rectangulo r1, r2, r3;\n\nr1 = new Rectangulo ();\n\nr2 = new Rectangulo ();\n\nr3 = new Rectangulo (); \n</code></pre>"},{"location":"#33-manipulacion-de-un-objeto","title":"3.3 Manipulaci\u00f3n de un objeto","text":"<p>Una vez que un objeto ha sido declarado y creado (clase instanciada)  ya s\u00ed se puede decir que el objeto existe en el entorno de ejecuci\u00f3n, y  por tanto que puede ser manipulado como un objeto m\u00e1s en el programa,  haci\u00e9ndose uso de sus atributos y sus m\u00e9todos.</p> <p>Para acceder a un miembro de un objeto se utiliza el operador punto (.) del siguiente modo:</p> <pre><code>&lt;nombreObjeto&gt;.&lt;nombreMiembro&gt;\n</code></pre> <p>Donde <code>&lt;nombreMiembro&gt;</code> ser\u00e1 el nombre de alg\u00fan miembro del objeto (atributo o m\u00e9todo) al cual se tenga acceso.</p> <p>Por ejemplo, en el caso de los objetos de tipo <code>Punto</code> que hemos declarado e instanciado en los apartados anteriores, podr\u00edamos  acceder a sus miembros de la siguiente manera siempre que los hayamos  declarado como p\u00fablicos:</p> <pre><code>Punto p1, p2, p3;\n\np1 = new Punto();\n\np1.x = 5;\n\np1.y = 6;\n\nSystem.out.printf(\"p1.x: %d\\np1.y: %d\\n\", p1.x, p1.y);\n\nSystem.out.printf(\"p1.x: %d\\np1.y: %d\\n\", p1.obtenerX(), p1.obtenerY());\n\np1.establecerX(25);\n\np1.establecerX(30);\n\nSystem.out.printf(\"p1.x: %d\\np1.y: %d\\n\", p1.obtenerX(), p1.obtenerY()); \n</code></pre> <p>Es decir, colocando el operador punto (.) a continuaci\u00f3n del nombre del objeto y seguido del nombre del miembro al que se desea acceder.</p>"},{"location":"#ejercicio_5","title":"Ejercicio","text":"<p>Utilizar el ejemplo de los rect\u00e1ngulos para crear un rect\u00e1ngulo r1, asignarle los valores x1 = 0, y1 = 0, x2 = 10, y2 = 10, calcular su \u00e1rea y su per\u00edmetro y mostrarlos en pantalla.</p>"},{"location":"#4-encapsulacion-control-de-acceso-y-visibilidad","title":"4. Encapsulaci\u00f3n, control de acceso y visibilidad","text":"<p>Dentro de la Programaci\u00f3n Orientada a Objetos ya has visto que es muy importante el concepto de ocultaci\u00f3n, la cual ha sido lograda gracias a la encapsulaci\u00f3n de la informaci\u00f3n dentro de las clases.  De esta manera una clase puede ocultar parte de su contenido o restringir el acceso a \u00e9l para evitar que sea manipulado de manera inadecuada. Los modificadores de acceso en Java permiten especificar el \u00e1mbito de visibilidad de los miembros de una clase, proporcionando as\u00ed un mecanismo de accesibilidad a varios niveles.</p> <p>Acabas de estudiar que cuando se definen los miembros de una clase (atributos o m\u00e9todos), e incluso la propia clase, se indica (aunque sea por omisi\u00f3n) un modificador de acceso. En funci\u00f3n de la visibilidad que se desee que tengan los objetos o los miembros de esos objetos se elegir\u00e1 alguno de los modificadores de acceso que has estudiado. Ahora que ya sabes c\u00f3mo escribir una clase completa (declaraci\u00f3n de la clase, declaraci\u00f3n de sus atributos y declaraci\u00f3n de sus m\u00e9todos), vamos a hacer un repaso general de las opciones de visibilidad (control de acceso) que has estudiado.</p> <p>Los modificadores de acceso determinan si una clase puede utilizar determinados miembros (acceder a atributos o invocar miembros) de otra clase. Existen dos niveles de control de acceso:</p> <ol> <li>A nivel general (nivel de clase): visibilidad de la propia clase.</li> <li>A nivel de miembros: especificaci\u00f3n, miembro por miembro, de su nivel de visibilidad.</li> </ol> <p>En el caso de la clase, ya estudiaste que los niveles de visibilidad pod\u00edan ser:</p> <ul> <li>P\u00fablico (modificador <code>public</code>), en cuyo caso la clase era visible a cualquier otra clase (cualquier otro fragmento de c\u00f3digo del programa).</li> <li>Privada al paquete (sin modificador o modificador \"por omisi\u00f3n\"). En este caso, la clase s\u00f3lo ser\u00e1 visible a las dem\u00e1s clases del mismo paquete, pero no al resto del c\u00f3digo del programa (otros paquetes).</li> </ul> <p>En el caso de los miembros, dispon\u00edas de otras dos posibilidades m\u00e1s de niveles de accesibilidad, teniendo un total de cuatro opciones a la hora de definir el control de acceso al miembro:</p> <ul> <li>P\u00fablico (modificador <code>public</code>), igual que en el caso global de la clase y con el mismo significado (miembro visible desde cualquier parte del c\u00f3digo).</li> <li>Privado al paquete (sin modificador), tambi\u00e9n con el mismo significado que en el caso de la clase (miembro visible s\u00f3lo desde clases del mismo paquete, ni siquiera ser\u00e1 visible desde una subclase salvo si \u00e9sta est\u00e1 en el mismo paquete). </li> <li>Privado (modificador <code>private</code>), donde s\u00f3lo la propia clase tiene acceso al miembro.</li> <li>Protegido (modificador <code>protected</code>)</li> </ul>"},{"location":"#para-saber-mas_2","title":"Para saber m\u00e1s","text":"<p>Puedes echar un vistazo al art\u00edculo sobre el control de acceso a los  miembros de una clase Java en los manuales de Oracle (en ingl\u00e9s):</p> <p>Controlling Access to Members of a Class.</p>"},{"location":"#41-ocultacion-de-atributos-metodos-de-acceso","title":"4.1 Ocultaci\u00f3n de atributos. M\u00e9todos de acceso","text":"<p>Los atributos de una clase suelen ser declarados como privados a la clase o, como mucho, <code>protected</code> (accesibles tambi\u00e9n por clases heredadas), pero no como <code>public</code>. De esta manera puedes evitar que sean manipulados inadecuadamente (por  ejemplos modificarlos sin ning\u00fan tipo de control) desde el exterior del  objeto.</p> <p>En estos casos lo que se suele hacer es declarar esos atributos como  privados o protegidos y crear m\u00e9todos p\u00fablicos que permitan acceder a  esos atributos. Si se trata de un atributo cuyo contenido puede ser  observado pero no modificado directamente, puede implementarse un m\u00e9todo de \"obtenci\u00f3n\" del atributo (en ingl\u00e9s se les suele llamar m\u00e9todo de  tipo get) y si el atributo puede ser modificado, puedes tambi\u00e9n implementar otro m\u00e9todo para la  modificaci\u00f3n o \"establecimiento\" del valor del atributo (en ingl\u00e9s se le suele llamar m\u00e9todo de tipo set). Esto ya lo has visto en apartados anteriores.</p> <p>Si recuerdas la clase <code>Punto</code> que hemos utilizado como ejemplo, ya hiciste algo as\u00ed con los m\u00e9todos de obtenci\u00f3n y establecimiento de las coordenadas:</p> <pre><code>private int x, y;\n\n// M\u00e9todos get\n\npublic int obtenerX() {\n    return x;\n}\n\npublic int obtenerY() {\n    return y;\n}\n\n// M\u00e9todos set\n\npublic void establecerX(int x) {\n    this.x = x;\n}\n\npublic void establecerY(int y) {\n    this.y = y;\n} \n</code></pre> <p>As\u00ed, para poder obtener el valor del atributo <code>x</code> de un objeto de tipo <code>Punto</code> ser\u00e1 necesario utilizar el m\u00e9todo <code>obtenerX()</code> y no se podr\u00e1 acceder directamente al atributo <code>x</code> del objeto.</p> <p>En algunos casos los programadores directamente utilizan nombres en ingl\u00e9s para nombrar a estos m\u00e9todos: <code>getX ,getY (), setX, setY, getNombre, setNombre, getColor</code>, etc.</p> <p>Tambi\u00e9n pueden darse casos en los que no interesa que pueda  observarse directamente el valor de un atributo, sino un determinado  procesamiento o c\u00e1lculo que se haga con el atributo (pero no el valor  original). Por ejemplo podr\u00edas tener un atributo DNI que almacene los 8 d\u00edgitos del DNI pero no la letra del NIF (pues se puede calcular a partir de los d\u00edgitos). El m\u00e9todo de acceso para el DNI (m\u00e9todo <code>getDNI</code>) podr\u00eda proporcionar el DNI completo (es decir, el NIF, incluyendo la  letra), mientras que la letra no es almacenada realmente en el atributo  del objeto. Algo similar podr\u00eda suceder con el d\u00edgito de control de una cuenta bancaria, que puede no ser almacenado en el objeto, pero s\u00ed calculado y devuelto cuando se nos pide el n\u00famero de cuenta completo.</p> <p>En otros casos puede interesar disponer de m\u00e9todos de modificaci\u00f3n de un atributo pero a trav\u00e9s de un determinado procesamiento previo para  por ejemplo poder controlar errores o valores inadecuados. Volviendo al  ejemplo del NIF, un m\u00e9todo para modificar un DNI (m\u00e9todo <code>setDNI</code>) podr\u00eda incluir la letra (NIF completo), de manera que as\u00ed podr\u00eda  comprobarse si el n\u00famero de DNI y la letra coinciden (es un NIF v\u00e1lido). En tal caso se almacenar\u00e1 el DNI y en caso contrario se producir\u00e1 un  error de validaci\u00f3n (por ejemplo lanzando una excepci\u00f3n). En cualquier  caso, el DNI que se almacenara ser\u00eda solamente el n\u00famero y no la letra  (pues la letra es calculable a partir del n\u00famero de DNI).</p>"},{"location":"#42-ocultacion-de-metodos","title":"4.2 Ocultaci\u00f3n de m\u00e9todos","text":"<p>Normalmente los m\u00e9todos de una clase pertenecen a su interfaz y por tanto parece l\u00f3gico que sean declarados como p\u00fablicos. Pero tambi\u00e9n es cierto que pueden darse casos en los que exista la necesidad de disponer de algunos m\u00e9todos privados a la clase. Se trata de m\u00e9todos que realizan operaciones intermedias o auxiliares y que son utilizados por los m\u00e9todos que s\u00ed forman parte de la interfaz. Ese tipo de m\u00e9todos (de comprobaci\u00f3n, de adaptaci\u00f3n de formatos, de c\u00e1lculos intermedios, etc.) suelen declararse como privados pues no son de inter\u00e9s (o no es apropiado que sean visibles) fuera del contexto del interior del objeto.</p> <p>En el ejemplo anterior de objetos que contienen un DNI, ser\u00e1 necesario calcular la letra correspondiente a un determinado n\u00famero de DNI o comprobar si una determinada combinaci\u00f3n de n\u00famero y letra forman un DNI v\u00e1lido. Este tipo de c\u00e1lculos y comprobaciones podr\u00edan ser implementados en m\u00e9todos privados de la clase (o al menos como m\u00e9todos protegidos).</p>"},{"location":"#ejercicio_6","title":"Ejercicio","text":"<p>Vamos a intentar implementar una clase que incluya todo lo que has  visto hasta ahora. Se desea crear una clase que represente un DNI espa\u00f1ol y que tenga las siguientes caracter\u00edsticas:</p> <ul> <li> <p>La clase almacenar\u00e1 el n\u00famero de DNI en un <code>int</code>, sin  guardar la letra, pues se puede calcular a partir del n\u00famero. Este  atributo ser\u00e1 privado a la clase. Formato del atributo: <code>private int numDNI</code>.</p> </li> <li> <p>Para acceder al DNI se dispondr\u00e1 de dos m\u00e9todos obtener (get), uno que proporcionar\u00e1 el n\u00famero de DNI (s\u00f3lo las cifras num\u00e9ricas) y otro que devolver\u00e1 el NIF  completo (incluida la letra). El formato del m\u00e9todo ser\u00e1:</p> </li> </ul> <pre><code>public int obtenerDNI ().\n\npublic String obtenerNIF ().  \n</code></pre> <ul> <li>Para modificar el DNI se dispondr\u00e1 de dos m\u00e9todos establecer (<code>set</code>), que permitir\u00e1n modificar el DNI. Uno en el que habr\u00e1 que proporcionar  el NIF completo (n\u00famero y letra). Y otro en el que \u00fanicamente ser\u00e1  necesario proporcionar el DNI (las siete u ocho cifras). Si el DNI/NIF  es incorrecto se deber\u00eda lanzar alg\u00fan tipo de excepci\u00f3n. El formato de los m\u00e9todos (sobrecargados) ser\u00e1:</li> </ul> <pre><code>public void establecer (String nif) throws ...\n\npublic void establecer (int dni) throws ...\n</code></pre> <ul> <li>La clase dispondr\u00e1 de algunos m\u00e9todos internos privados para calcular la letra de un n\u00famero de DNI cualquiera, para comprobar si un DNI con su  letra es v\u00e1lido, para extraer la letra de un NIF, etc. Aquellos m\u00e9todos  que no utilicen ninguna variable de objeto podr\u00edan declararse como  est\u00e1ticos (pertenecientes a la clase). Formato de los m\u00e9todos:</li> </ul> <pre><code>private static char calcularLetraNIF (int dni).\n\nprivate boolean validarNIF (String nif).\n\nprivate static char extraerLetraNIF (String nif).\n\nprivate static int extraerNumeroNIF (String nif).\n</code></pre> <ul> <li>Para calcular la letra NIF correspondiente a un n\u00famero de DNI puedes consultar el ejercicio que se ha realizado en la unidad de las funciones.</li> </ul>"},{"location":"#5-constructores","title":"5. Constructores","text":"<p>Como ya has estudiado en unidades anteriores, en el ciclo de vida de un objeto se pueden distinguir las fases de:</p> <ul> <li>Construcci\u00f3n del objeto.</li> <li>Manipulaci\u00f3n y utilizaci\u00f3n del objeto accediendo a sus miembros.</li> <li>Destrucci\u00f3n del objeto.</li> </ul> <p>Como has visto en el apartado anterior, durante la fase de  construcci\u00f3n o instanciaci\u00f3n de un objeto es cuando se reserva espacio  en memoria para sus atributos y se inicializan algunos de ellos. Un constructor es un m\u00e9todo especial con el mismo nombre de la clase y que se encarga de realizar este proceso.</p> <p>El proceso de declaraci\u00f3n y creaci\u00f3n de un objeto mediante el operador new ya ha sido estudiado en apartados anteriores. Sin embargo las clases  que hasta ahora has creado no ten\u00edan constructor. Has estado utilizando  los constructores por defecto que proporciona Java al compilar la clase. Ha llegado el momento de que empieces a implementar tus propios  constructores.</p> Los m\u00e9todos constructores se encargan de llevar a cabo el proceso de creaci\u00f3n o construcci\u00f3n de un objeto."},{"location":"#51-concepto-de-constructor","title":"5.1 Concepto de constructor","text":"<p>Un constructor es un m\u00e9todo que tiene el mismo nombre que la clase a la que pertenece y que no devuelve ning\u00fan valor tras su ejecuci\u00f3n. Su funci\u00f3n es la de proporcionar el mecanismo de creaci\u00f3n de instancias (objetos) de la clase.</p> <p>Cuando un objeto es declarado, en realidad a\u00fan no existe. Tan solo se trata de un nombre simb\u00f3lico (una variable) que en el futuro har\u00e1 referencia a una zona de memoria que contendr\u00e1 la informaci\u00f3n que representa realmente a un objeto. Para que esa variable de objeto a\u00fan \"vac\u00eda\" (se suele decir que es una referencia nula o vac\u00eda) apunte, o haga referencia a una zona de memoria que represente a una instancia de clase (objeto) existente, es necesario \"construir\" el objeto. Ese proceso se realizar\u00e1 a trav\u00e9s del m\u00e9todo constructor de la clase.</p> <p>Por tanto para crear un nuevo objeto es necesario realizar una llamada a un m\u00e9todo constructor de la clase a la que pertenece ese objeto. Ese proceso se realiza mediante la utilizaci\u00f3n del operador <code>new</code>.</p> <p>Hasta el momento ya has utilizado en numerosas ocasiones el operador <code>new</code> para instanciar o crear objetos. En realidad lo que estabas haciendo era una llamada al constructor de la clase para que reservara memoria para ese objeto y por tanto \"crear\" f\u00edsicamente el objeto en la memoria (dotarlo de existencia f\u00edsica dentro de la memoria del ordenador). Dado que en esta unidad est\u00e1s ya definiendo tus propias clases, parece que ha llegado el momento de que empieces a escribir tambi\u00e9n los constructores de tus clases.</p> <p>Por otro lado, si un constructor es al fin y al cabo una especie de m\u00e9todo (aunque algo especial) y Java soporta la sobrecarga de m\u00e9todos, podr\u00edas plantearte la siguiente pregunta: \u00bfpodr\u00e1 una clase disponer de m\u00e1s de constructor? En otras palabras, \u00bfser\u00e1 posible la sobrecarga de constructores? La respuesta es afirmativa.</p> Una misma clase puede disponer de varios constructores. Los constructores soportan la sobrecarga. <p>Es necesario que toda clase tenga al menos un constructor. Si no se define ning\u00fan constructor en una clase, el compilador crear\u00e1 por nosotros un constructor por defecto vac\u00edo que se encarga de inicializar todos los atributos a sus valores por defecto (0 para los num\u00e9ricos, <code>null</code> para las referencias, <code>false</code> para los <code>boolean</code>, etc.).</p> <p>Algunas analog\u00edas que podr\u00edas imaginar para representar el constructor de una clase podr\u00edan ser:</p> <ul> <li>Los moldes de cocina para flanes, galletas, pastas, etc.</li> <li>Un cubo de playa para crear castillos de arena.</li> <li>Un molde de un lingote de oro.</li> <li>Una bolsa para hacer cubitos de hielo.</li> </ul> <p>Una vez que incluyas un constructor personalizado a una clase, el compilador ya no incluir\u00e1 el constructor por defecto (sin par\u00e1metros) y por tanto si intentas usarlo se producir\u00eda un error de compilaci\u00f3n. Si quieres que tu clase tenga tambi\u00e9n un constructor sin par\u00e1metros tendr\u00e1s que escribir su c\u00f3digo (ya no lo har\u00e1 por ti el compilador).</p>"},{"location":"#511-sobrecarga-de-metodos","title":"5.1.1 Sobrecarga de m\u00e9todos","text":"<p>En principio podr\u00edas pensar que un m\u00e9todo puede aparecer una sola vez en la declaraci\u00f3n de una clase (no se deber\u00eda repetir el mismo nombre  para varios m\u00e9todos). Pero no tiene porqu\u00e9 siempre suceder as\u00ed. Es  posible tener varias versiones de un mismo m\u00e9todo (varios m\u00e9todos con el mismo nombre) gracias a la sobrecarga de m\u00e9todos.</p> <p>El lenguaje Java soporta la caracter\u00edstica conocida como sobrecarga de m\u00e9todos. \u00c9sta permite declarar en una misma clase varias versiones del mismo  m\u00e9todo con el mismo nombre. La forma que tendr\u00e1 el compilador de  distinguir entre varios m\u00e9todos que tengan el mismo nombre ser\u00e1 mediante la lista de par\u00e1metros del m\u00e9todo: si el m\u00e9todo tiene una lista de  par\u00e1metros diferente, ser\u00e1 considerado como un m\u00e9todo diferente (aunque  tenga el mismo nombre) y el analizador l\u00e9xico no producir\u00e1 un error de  compilaci\u00f3n al encontrar dos nombres de m\u00e9todo iguales en la misma  clase.</p> <p>Imag\u00ednate que est\u00e1s desarrollando una clase para escribir sobre un  lienzo que permite utilizar diferentes tipograf\u00edas en funci\u00f3n del tipo  de informaci\u00f3n que se va a escribir. Es probable que necesitemos un  m\u00e9todo diferente seg\u00fan se vaya a pintar un n\u00famero entero (<code>int</code>), un n\u00famero real (<code>double</code>) o una cadena de caracteres (<code>String</code>). Una primera opci\u00f3n podr\u00eda ser definir un nombre de m\u00e9todo diferente  dependiendo de lo que se vaya a escribir en el lienzo. Por ejemplo:</p> <ul> <li>M\u00e9todo <code>pintarEntero(int entero)</code>.</li> <li>M\u00e9todo <code>pintarReal(double real)</code>.</li> <li>M\u00e9todo <code>pintarCadena(double String)</code>.</li> <li>M\u00e9todo <code>pintarEnteroCadena(int entero, String cadena)</code>.</li> </ul> <p>Y as\u00ed sucesivamente para todos los casos que desees contemplar...</p> <p>La posibilidad que te ofrece la sobrecarga es utilizar un mismo  nombre para todos esos m\u00e9todos (dado que en el fondo hacen lo mismo:  pintar). Pero para poder distinguir unos de otros ser\u00e1 necesario que  siempre exista alguna diferencia entre ellos en las listas de par\u00e1metros (bien en el n\u00famero de par\u00e1metros, bien en el tipo de los par\u00e1metros).  Volviendo al ejemplo anterior, podr\u00edamos utilizar un mismo nombre, por  ejemplo <code>pintar</code>, para todos los m\u00e9todos anteriores:</p> <ul> <li>M\u00e9todo <code>pintar(int entero)</code>.</li> <li>M\u00e9todo <code>pintar(double real)</code>.</li> <li>M\u00e9todo <code>pintar(double String)</code>.</li> <li>M\u00e9todo <code>pintar(int entero, String cadena)</code>.</li> </ul> <p>En este caso el compilador no va a generar ning\u00fan error pues se  cumplen las normas ya que unos m\u00e9todos son perfectamente distinguibles  de otros (a pesar de tener el mismo nombre) gracias a que tienen listas  de par\u00e1metros diferentes.</p> <p>Lo que s\u00ed habr\u00eda producido un error de compilaci\u00f3n habr\u00eda sido por ejemplo incluir otro m\u00e9todo <code>pintar(int entero)</code>, pues es imposible distinguirlo de otro m\u00e9todo con el mismo nombre y con la misma lista de par\u00e1metros (ya existe un m\u00e9todo <code>pintar</code> con un \u00fanico par\u00e1metro de tipo <code>int</code>).</p> <p>Tambi\u00e9n debes tener en cuenta que el tipo devuelto por el m\u00e9todo no es considerado a la hora de identificar un m\u00e9todo, as\u00ed que un tipo devuelto diferente no es suficiente para distinguir un m\u00e9todo  de otro. Es decir, no podr\u00edas definir dos m\u00e9todos exactamente iguales en nombre y lista de par\u00e1metros e intentar distinguirlos indicando un tipo devuelto diferente. El compilador producir\u00e1 un error de duplicidad en  el nombre del m\u00e9todo y no te lo permitir\u00e1.</p> Es conveniente no abusar de sobrecarga de m\u00e9todos y utilizarla con  cierta moderaci\u00f3n (cuando realmente puede beneficiar su uso), dado que  podr\u00eda hacer el c\u00f3digo menos legible."},{"location":"#52-creacion-de-constructores","title":"5.2 Creaci\u00f3n de constructores","text":"<p>Cuando se escribe el c\u00f3digo de una clase normalmente se pretende que los objetos de esa clase se creen de una determinada manera. Para ello se definen uno o m\u00e1s constructores en la clase. En la definici\u00f3n de un constructor se indican:</p> <ul> <li>El tipo de acceso.</li> <li>El nombre de la clase (el nombre de un m\u00e9todo constructor es siempre el nombre de la propia clase).</li> <li>La lista de par\u00e1metros que puede aceptar.</li> <li>Si lanza o no excepciones.</li> <li>El cuerpo del constructor (un bloque de c\u00f3digo como el de cualquier m\u00e9todo).</li> </ul> <p>Como puedes observar, la estructura de los constructores es similar a la de cualquier m\u00e9todo, con las excepciones de que no tiene tipo de dato devuelto (no devuelve ning\u00fan valor) y que el nombre del m\u00e9todo constructor debe ser obligatoriamente el nombre de la clase.</p>"},{"location":"#reflexiona","title":"Reflexiona","text":"<p>Si defines constructores personalizados para una clase, el constructor  por defecto (sin par\u00e1metros) para esa clase deja de ser generado por el  compilador, de manera que tendr\u00e1s que crearlo t\u00fa si quieres poder  utilizarlo.</p> <p>Si se ha creado un constructor con par\u00e1metros y no se ha implementado el constructor por defecto, el intento de utilizaci\u00f3n del constructor  por defecto producir\u00e1 un error de compilaci\u00f3n (el compilador no lo har\u00e1  por nosotros).</p> <p>Un ejemplo de constructor para la clase <code>Punto</code> podr\u00eda ser:</p> <pre><code> public Punto(int x, int y) {\n\n     this.x = x;\n\n     this.y = y;\n\n     cantidadPuntos++;  // Suponiendo que tengamos un atributo est\u00e1tico cantidadPuntos\n\n}\n</code></pre> <p>En este caso el constructor recibe dos par\u00e1metros. Adem\u00e1s de reservar espacio para los atributos (de lo cual se encarga autom\u00e1ticamente  Java), tambi\u00e9n asigna sendos valores iniciales a los atributos x e y.  Por \u00faltimo incrementa un atributo (probablemente est\u00e1tico) llamado <code>cantidadPuntos</code>.</p> <p></p>"},{"location":"#521-la-referencia-this","title":"5.2.1 La referencia this","text":"<p>La palabra reservada <code>this</code> consiste en una referencia al  objeto actual. El uso de este operador puede resultar muy \u00fatil a la hora de evitar la ambig\u00fcedad que puede producirse entre el nombre de un  par\u00e1metro de un m\u00e9todo y el nombre de un atributo cuando ambos tienen el mismo identificador (mismo nombre). En tales casos el par\u00e1metro  \"oculta\" al atributo y no tendr\u00edamos acceso directo a \u00e9l (al escribir el identificador estar\u00edamos haciendo referencia al par\u00e1metro y no al  atributo). En estos casos la referencia <code>this</code> nos permite acceder a estos atributos ocultados por los par\u00e1metros.</p> <p></p> <p>Dado que this es una referencia a la propia clase en la que te  encuentras en ese momento, puedes acceder a sus atributos mediante el  operador punto (.) como sucede con cualquier otra clase u objeto. Por  tanto, en lugar de poner el nombre del atributo (que estos casos har\u00eda  referencia al par\u00e1metro), podr\u00edas escribir <code>this.nombreAtributo</code>, de manera que el compilador sabr\u00e1 que te est\u00e1s refiriendo al atributo y se eliminar\u00e1 la ambig\u00fcedad.</p> <p>En el ejemplo de la clase <code>Punto</code>, podr\u00edamos utilizar la referencia <code>this</code> si el nombre del par\u00e1metro del m\u00e9todo coincidiera con el del atributo que se desea modificar. Por ejemplo:</p> <pre><code> void establecerX(int x) {\n\n     this.x = x;\n\n}\n</code></pre> <p>En este caso ha sido indispensable el uso de <code>this</code>, pues si no ser\u00eda imposible saber en qu\u00e9 casos te est\u00e1s refiriendo al par\u00e1metro <code>x</code> y en cu\u00e1les al atributo <code>x</code>. Para el compilador el identificador <code>x</code> ser\u00e1 siempre el par\u00e1metro, pues ha \"ocultado\" al atributo.</p> En algunos casos puede resultar \u00fatil hacer uso de la referencia <code>this</code> aunque no sea necesario, pues puede ayudar a mejorar la legibilidad del c\u00f3digo."},{"location":"#para-saber-mas_3","title":"Para saber m\u00e1s","text":"<p>Puedes echar un vistazo al art\u00edculo general sobre la referencia this en los manuales de Oracle (en ingl\u00e9s): Using the this Keyword.</p>"},{"location":"#ejercicio_7","title":"Ejercicio","text":"<p>Modificar el m\u00e9todo obtenerNombre de la clase Rectangulo de ejercicios anteriores utilizando la referencia <code>this</code>.</p> <pre><code>public void establecerNombre(String nombre) {\n\n    this.nombre = nombre;\n\n}\n</code></pre>"},{"location":"#53-utilizacion-de-constructores","title":"5.3 Utilizaci\u00f3n de constructores","text":"<p>Una vez que dispongas de tus propios constructores personalizados, la forma de utilizarlos es igual que con el constructor por defecto  (mediante la utilizaci\u00f3n de la palabra reservada <code>new</code>) pero  teniendo en cuenta que si has declarado par\u00e1metros en tu m\u00e9todo  constructor, tendr\u00e1s que llamar al constructor con alg\u00fan valor para esos par\u00e1metros.</p> <p>Un ejemplo de utilizaci\u00f3n del constructor que has creado para la clase Punto en el apartado anterior podr\u00eda ser:</p> <pre><code>Punto p1;\n\np1 = new Punto(10, 7); \n</code></pre> <p>En este caso no se estar\u00eda utilizando el constructor por defecto sino el constructor que acabas de implementar en el cual adem\u00e1s de reservar  memoria se asigna un valor a algunos de los atributos.</p>"},{"location":"#_1","title":"Unidad 5. POO Clases y Objetos","text":""},{"location":"#para-saber-mas_4","title":"Para saber m\u00e1s","text":"<p>Puedes echar un vistazo al art\u00edculo sobre constructores de una clase Java en los manuales de Oracle (en ingl\u00e9s): Providing Constructors for Your Classes.</p>"},{"location":"#ejercicio_8","title":"Ejercicio","text":"<p>Ampliar el ejercicio de la clase Rectangulo a\u00f1adi\u00e9ndole tres constructores:</p> <ul> <li> <p>Un constructor sin par\u00e1metros (para sustituir al constructor por defecto) que haga que los valores iniciales de las esquinas del rect\u00e1ngulo sean (0,0) y (1,1);</p> </li> <li> <p>Un constructor con cuatro par\u00e1metros, x1, y1, x2, y2, que rellene los valores iniciales de los atributos del rect\u00e1ngulo con los valores proporcionados a trav\u00e9s de los par\u00e1metros.</p> </li> <li> <p>Un constructor con dos par\u00e1metros, base y altura, que cree un rect\u00e1ngulo donde el v\u00e9rtice inferior derecho est\u00e9 ubicado en la posici\u00f3n (0,0) y que tenga una base y una altura tal y como indican los dos par\u00e1metros proporcionados.</p> </li> </ul>"},{"location":"#54-constructores-copia","title":"5.4 Constructores copia","text":"<p>Una forma de iniciar un objeto podr\u00eda ser mediante la copia de los  valores de los atributos de otro objeto ya existente. Imagina que  necesitas varios objetos iguales (con los mismos valores en sus  atributos) y que ya tienes uno de ellos perfectamente configurado (sus  atributos contienen los valores que t\u00fa necesitas). Estar\u00eda bien disponer de un constructor que hiciera copias id\u00e9nticas de ese objeto.</p> <p>Durante el proceso de creaci\u00f3n de un objeto puedes generar objetos  exactamente iguales (basados en la misma clase) que se distinguir\u00e1n  posteriormente porque podr\u00e1n tener estados distintos (valores diferentes en los atributos). La idea es poder decirle a la clase que adem\u00e1s de  generar un objeto nuevo, que lo haga con los mismos valores que tenga  otro objeto ya existente. Es decir, algo as\u00ed como si pudieras clonar el objeto tantas veces como te haga falta. A este tipo de mecanismo se le suele llamar constructor copia o constructor de copia.</p> <p>Un constructor copia es un m\u00e9todo constructor como los que ya has  utilizado pero con la particularidad de que recibe como par\u00e1metro una  referencia al objeto cuyo contenido se desea copiar. Este m\u00e9todo revisa  cada uno de los atributos del objeto recibido como par\u00e1metro y se copian todos sus valores en los atributos del objeto que se est\u00e1 creando en  ese momento en el m\u00e9todo constructor.</p> <p>Un ejemplo de constructor copia para la clase <code>Punto</code> podr\u00eda ser:</p> <pre><code>public Punto(Punto p) {\n\n     this.x = p.obtenerX();\n\n     this.y = p.obtenerY();\n\n}\n</code></pre> <p>En este caso el constructor recibe como par\u00e1metro un objeto del mismo tipo que el que va a ser creado (clase <code>Punto</code>), inspecciona el valor de sus atributos (atributos <code>x</code> e <code>y</code>), y los reproduce en los atributos del objeto en proceso de construcci\u00f3n (<code>this</code>).</p> <p>Un ejemplo de utilizaci\u00f3n de ese constructor podr\u00eda ser:</p> <pre><code>Punto p1, p2;\n\np1 = new Punto(10, 7);\n\np2 = new Punto(p1); \n</code></pre>"},{"location":"#ejercicio_9","title":"Ejercicio","text":"<p>Ampliar el ejercicio de la clase  <code>Rectangulo</code>  a\u00f1adi\u00e9ndole un constructor copia.</p> <p>Se trata de a\u00f1adir un nuevo constructor adem\u00e1s de los tres que ya hab\u00edamos creado:</p> <pre><code>public Rectangulo(Rectangulo r) {\n\n    this.x1 = r.x1;\n\n    this.y1 = r.y1;\n\n    this.x2 = r.x2;\n\n    this.y2 = r.y2;\n\n}\n</code></pre> <p>Para usar este constructor basta con haber creado anteriormente otro <code>Rectangulo</code> para utilizarlo como base de la copia. Por ejemplo:</p> <pre><code>Rectangulo r1, r2;\n\nr1 = new Rectangulo(0,0,2,2);\n\nr2 = new Rectangulo  (r1); \n</code></pre>"},{"location":"#55-destruccion-de-objetos","title":"5.5 Destrucci\u00f3n de objetos","text":"<p>Como ya has estudiado en unidades anteriores, cuando un objeto deja  de ser utilizado, los recursos usados por \u00e9l (memoria, acceso a  archivos, conexiones con bases de datos, etc.) deber\u00edan de ser liberados para que puedan volver a ser utilizados por otros procesos (mecanismo  de destrucci\u00f3n del objeto).</p> <p>Mientras que de la construcci\u00f3n de los objetos se encargan los  m\u00e9todos constructores, de la destrucci\u00f3n se encarga un proceso del  entorno de ejecuci\u00f3n conocido como recolector de basura (garbage collector). Este proceso va buscando peri\u00f3dicamente objetos que ya no son  referenciados (no hay ninguna variable que haga referencia a ellos) y  los marca para ser eliminados. Posteriormente los ir\u00e1 eliminando de la  memoria cuando lo considere oportuno (en funci\u00f3n de la carga del  sistema, los recursos disponibles, etc.).</p> <p>Normalmente se suele decir que en Java no hay m\u00e9todo destructor y que en otros lenguajes orientados a objetos como C++, s\u00ed se implementa expl\u00edcitamente el destructor de una clase de la misma  manera que se define el constructor. En realidad en Java tambi\u00e9n es  posible implementar el m\u00e9todo destructor de una clase, se trata del  m\u00e9todo <code>finalize()</code>.</p> <p>Este m\u00e9todo <code>finalize</code> es llamado por el recolector de  basura cuando va a destruir el objeto (lo cual nunca se sabe cu\u00e1ndo va a suceder exactamente, pues una cosa es que el objeto sea marcado para  ser borrado y otra que sea borrado efectivamente). Si ese m\u00e9todo no  existe, se ejecutar\u00e1 un destructor por defecto (el m\u00e9todo <code>finalize</code> que contiene la clase <code>Object</code>, de la cual heredan todas las clases en Java) que liberar\u00e1 la memoria  ocupada por el objeto. Se recomienda por tanto que si un objeto utiliza  determinados recursos de los cuales no tienes garant\u00eda que el entorno de ejecuci\u00f3n los vaya a liberar (cerrar archivos, cerrar conexiones de  red, cerrar conexiones con bases de datos, etc.), implementes  expl\u00edcitamente un m\u00e9todo <code>finalize</code> en tus clases. Si el  \u00fanico recurso que utiliza tu clase es la memoria necesaria para albergar sus atributos, eso s\u00ed ser\u00e1 liberado sin problemas. Pero si se trata de  algo m\u00e1s complejo, ser\u00e1 mejor que te encargues t\u00fa mismo de hacerlo  implementando tu destructor personalizado (<code>finalize</code>).</p> <p>Por otro lado, esta forma de funcionar del entorno de ejecuci\u00f3n de  Java (destrucci\u00f3n de objetos no referenciados mediante el recolector de  basura) implica que no puedas saber exactamente cu\u00e1ndo un objeto va a  ser definitivamente destruido, pues si una variable deja de ser  referenciada (se cierra el \u00e1mbito de ejecuci\u00f3n donde fue creada) no  implica necesariamente que sea inmediatamente borrada, sino que  simplemente es marcada para que el recolector la borre cuando pueda  hacerlo.</p> <p>Si en un momento dado fuera necesario garantizar que el proceso de finalizaci\u00f3n (m\u00e9todo <code>finalize</code>) sea invocado, puedes recurrir al m\u00e9todo <code>runFinalization ()</code> de la clase <code>System</code> para forzarlo:</p> <pre><code>System.runFinalization();\n</code></pre> <p>Este m\u00e9todo se encarga de llamar a todos los m\u00e9todos <code>finalize</code> de todos los objetos marcados por el recolector de basura para ser destruidos.</p> <p>Si necesitas implementar un destructor (normalmente no ser\u00e1 necesario), debes tener en cuenta que:</p> <ul> <li>El nombre del m\u00e9todo destructor debe ser <code>finalize ()</code>.</li> <li>No puede recibir par\u00e1metros.</li> <li>S\u00f3lo puede haber un destructor en una clase. No es posible la sobrecarga dado que no tiene par\u00e1metros.</li> <li>No puede devolver ning\u00fan valor. Debe ser de tipo <code>void</code>.</li> </ul>"},{"location":"#anexo-i-formateado-de-cadenas-en-java","title":"Anexo I.- Formateado de cadenas en Java","text":"<p>En Java, el m\u00e9todo est\u00e1tico format de la clase String permite formatear los datos que se muestran al usuario o la usuaria de la aplicaci\u00f3n. El m\u00e9todo <code>format</code> tiene los siguientes argumentos:</p> <ul> <li>Cadena de formato. Cadena que especifica c\u00f3mo ser\u00e1 el formato de  salida, en ella se mezclar\u00e1 texto normal con especificadores de formato, que indicar\u00e1n c\u00f3mo se debe formatear los datos.</li> <li>Lista de argumentos. Variables que contienen los datos cuyos datos  se formatear\u00e1n. Tiene que haber tantos argumentos como especificadores  de formato haya en la cadena de formato.</li> </ul> <p>Los especificadores de formato comienzan siempre por \"<code>%</code>\", es lo que se denomina un car\u00e1cter de escape (car\u00e1cter que sirve para  indicar que lo que hay a continuaci\u00f3n no es texto normal, sino algo  especial). El especificador de formato debe llevar como m\u00ednimo el  s\u00edmbolo \"<code>%</code>\" y un car\u00e1cter que indica la conversi\u00f3n a realizar, por ejemplo \"<code>%d</code>\".</p> <p>La conversi\u00f3n se indica con un simple car\u00e1cter, y se\u00f1ala al m\u00e9todo <code>format</code> c\u00f3mo debe ser formateado el argumento. Dependiendo del tipo de dato  podemos usar unas conversiones u otras. Veamos las conversiones m\u00e1s  utilizadas:</p>"},{"location":"#listado-de-conversiones-mas-utilizada-y-ejemplos","title":"Listado de conversiones m\u00e1s utilizada y ejemplos.","text":"Tipo de conversi\u00f3n Especificaci\u00f3n de formato Tipos de datos aplicables Ejemplo Resultado del ejemplo Valor l\u00f3gico o booleano. \"<code>%b</code>\" o \"<code>%B</code>\" <code>Boolean</code> (cuando se usan otros tipos de datos siempre lo formatear\u00e1 escribiendo <code>true</code>). <code>boolean b = true;</code> <code>String d = String.format(\"Resultado: %b\", b);</code> <code>System.out.println(d);</code> Resultado: <code>true</code> Cadena de caracteres. \"<code>%s</code>\" o \"<code>%S</code>\" Cualquiera, se convertir\u00e1 el objeto a cadena si es posible (invocando el m\u00e9todo <code>toString</code>). <code>String cad = \"hola mundo\";</code> <code>String d = String.format(\"Resultado: %s\", cad);</code> <code>System.out.println(d);</code> Resultado: <code>hola mundo</code> Entero decimal \"<code>%d</code>\" Un tipo de dato entero. <code>int i = 10;</code> <code>String d = String.format(\"Resultado: %d\", i);</code> <code>System.out.println(d);</code> Resultado: <code>10</code> N\u00famero en notaci\u00f3n cient\u00edfica \"<code>%e</code>\" o \"<code>%E</code>\" Flotantes simples o dobles. <code>double i = 10.5;</code> <code>String d = String.format(\"Resultado: %E\", i);</code> <code>System.out.println(d);</code> Resultado: <code>1.050000E+01</code> N\u00famero decimal \"<code>%f</code>\" Flotantes simples o dobles. <code>double i = 10.5;</code> <code>String d = String.format(\"Resultado: %f\", i);</code> <code>System.out.println(d);</code> Resultado: <code>10,500000</code> N\u00famero en notaci\u00f3n cient\u00edfica o decimal (lo m\u00e1s corto) \"<code>%g</code>\" o \"<code>%G</code>\" Flotantes simples o dobles. El n\u00famero se mostrar\u00e1 como decimal o en notaci\u00f3n cient\u00edfica dependiendo de lo que sea mas corto. <code>double i = 10.5;</code> <code>String d = String.format(\"Resultado: %g\", i);</code> <code>System.out.println(d);</code> Resultado: <code>10.5000</code> <p>Ahora que ya hemos visto alguna de las conversiones existentes (las  m\u00e1s importantes), veamos algunos modificadores que se le pueden aplicar a las conversiones, para ajustar como queremos que sea la salida. Los  modificadores se sit\u00faan entre el car\u00e1cter de escape (\"<code>%</code>\") y la letra que indica el tipo de conversi\u00f3n (d, f, g, etc.).</p> <p>Podemos especificar, por ejemplo, el n\u00famero de caracteres que tendr\u00e1  como m\u00ednimo la salida de una conversi\u00f3n. Si el dato mostrado no llega a  ese ancho en caracteres, se rellenar\u00e1 con espacios (salvo que se  especifique lo contrario):</p> <pre><code>%[Ancho]Conversi\u00f3n\n</code></pre> <p>El hecho de que est\u00e9 entre corchetes significa que es opcional. Si  queremos por ejemplo que la salida genere al menos 5 caracteres  (poniendo espacios delante) podr\u00edamos ponerlo as\u00ed:</p> <pre><code>String.format(\"%5d\", 10);\n</code></pre> <p>Se mostrar\u00e1 el \"10\" pero tambi\u00e9n se a\u00f1adir\u00e1n 3 espacios delante para  rellenar. Este tipo de modificador se puede usar con cualquier  conversi\u00f3n.</p> <p>Cuando se trata de conversiones de tipo num\u00e9ricas con decimales, solo para tipos de datos que admitan decimales, podemos indicar tambi\u00e9n la  precisi\u00f3n, que ser\u00e1 el n\u00famero de decimales m\u00ednimos que se mostrar\u00e1n:</p> <pre><code>%[Ancho][.Precisi\u00f3n]Conversi\u00f3n\n</code></pre> <p>Como puedes ver, tanto el ancho como la precisi\u00f3n van entre corchetes,  los corchetes no hay que ponerlos, solo indican que son modificaciones  opcionales. Si queremos, por ejemplo, que la salida genere 3 decimales  como m\u00ednimo, podremos ponerlo as\u00ed:</p> <pre><code>String.format(\"%.3f\", 4.2f);\n</code></pre> <p>Como el n\u00famero indicado como par\u00e1metro solo tiene un decimal, el  resultado se completar\u00e1 con ceros por la derecha, generando una cadena  como la siguiente: \"<code>4,200</code>\".</p> <p>Una cadena de formato puede contener varios especificadores de  formato y varios argumentos. Veamos un ejemplo de una cadena con varios  especificadores de formato:</p> <pre><code>String producto = \"Lavadora\";\n\nint cantidad = 10;\n\ndouble precio = 302.4;\n\ndouble total = cantidad * precio;\n\nString output = String.format(\"Producto: %s; Unidades: %d; Precio por unidad: %.2f \u20ac; Total: %.2f \u20ac\", producto, cantidad, precio, total);\n\nSystem.out.println(output);\n</code></pre> <p>Cuando el orden de los argumentos es un poco complicado, porque se  reutilizan varias veces en la cadena de formato los mismos argumentos,  se puede recurrir a los \u00edndices de argumento. Se trata de especificar la posici\u00f3n del argumento a utilizar, indicando la posici\u00f3n del argumento  (el primer argumento ser\u00eda el 1 y no el 0) seguido por el s\u00edmbolo del  d\u00f3lar (\"<code>$</code>\"). El \u00edndice se ubicar\u00eda al comienzo del especificador de formato, despu\u00e9s del porcentaje, por ejemplo:</p> <pre><code>int i = 10;\n\nint j = 20;\n\nString salida = String.format(\"%1$d multiplicado por %2$d (%1$d x %2$d) es %3$d\", i, j, i * j);\n\nSystem.out.println(salida);\n</code></pre> <p>El ejemplo anterior mostrar\u00eda por pantalla la cadena \"1<code>0 multiplicado por 20 (10 x 20) es 200</code>\". Los \u00edndices de argumento se pueden usar con todas las conversiones, y  es compatible con otros modificadores de formato (incluida la  precisi\u00f3n).</p>"},{"location":"#para-saber-mas_5","title":"Para saber m\u00e1s","text":"<p>Si quieres profundizar en los especificadores de formato puedes acceder a la siguiente p\u00e1gina (en ingl\u00e9s), donde encontrar\u00e1s informaci\u00f3n  adicional acerca de la sintaxis de los especificadores de formato en  Java: Sintaxis de los especificadores de formato.</p>"}]}